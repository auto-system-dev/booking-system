# 郵件發送邏輯完整說明

## 📧 郵件發送概述

系統使用 Gmail OAuth2 認證發送郵件，優先使用 Gmail API，失敗時自動切換到 SMTP。所有郵件發送都優先使用資料庫中的 `email_user` 設定。

---

## 📋 郵件類型總覽

| 郵件類型 | 收件人 | 觸發時機 | 發送方式 | 郵件狀態更新 |
|---------|--------|---------|---------|------------|
| **訂房確認** | 客戶 | 建立訂房時（匯款轉帳） | 即時發送 | ✅ 更新 |
| **新訂房通知** | 管理員 | 建立訂房時（所有付款方式） | 即時發送 | ❌ 不更新 |
| **付款完成確認** | 客戶 | 線上刷卡付款完成後 | 即時發送 | ✅ 更新 |
| **匯款期限提醒** | 客戶 | 定時任務（每小時檢查，依模板設定時間） | 定時發送 | ✅ 更新 |
| **入住提醒** | 客戶 | 定時任務（每小時檢查，依模板設定時間） | 定時發送 | ✅ 更新 |
| **回訪信** | 客戶 | 定時任務（每小時檢查，依模板設定時間） | 定時發送 | ✅ 更新 |
| **取消通知** | 客戶 | 自動取消過期保留訂房時 | 定時發送 | ❌ 不更新 |
| **驗證碼** | 客戶 | 申請查看/刪除個資時 | 即時發送 | ❌ 不更新 |
| **測試郵件** | 指定 Email | 後台測試郵件模板時 | 手動發送 | ❌ 不更新 |

---

## 🔄 詳細發送邏輯

### 1. 訂房確認郵件（客戶）

**觸發時機**：
- 客戶在前台提交訂房表單
- 付款方式為「匯款轉帳」
- ⚠️ **線上刷卡不會在建立訂房時發送確認郵件**，需等付款完成後

**發送位置**：`server.js` (855-920行)

**發送流程**：
```javascript
if (paymentMethod === 'transfer') {
    // 1. 生成客戶確認郵件內容
    const customerMailOptions = {
        from: emailUser,  // 優先使用資料庫設定
        to: guestEmail,
        subject: '【訂房確認】您的訂房已成功',
        html: await generateCustomerEmail(bookingData)
    };
    
    // 2. 優先使用 Gmail API 發送
    if (sendEmailViaGmailAPI) {
        try {
            await sendEmailViaGmailAPI(customerMailOptions);
        } catch (gmailError) {
            // Gmail API 失敗時，自動切換到 SMTP
            await transporter.sendMail(customerMailOptions);
        }
    } else {
        // 沒有 Gmail API，使用 SMTP
        await transporter.sendMail(customerMailOptions);
    }
    
    // 3. 更新郵件狀態
    if (emailSent) {
        await db.updateEmailStatus(bookingId, 'booking_confirmation');
    }
}
```

**郵件內容**：
- 訂房編號、入住/退房日期、房型、價格
- 匯款資訊（如果付款方式為匯款轉帳）
- 匯款期限提醒
- 旅館資訊 footer

---

### 2. 新訂房通知郵件（管理員）

**觸發時機**：
- 客戶在前台提交訂房表單
- **所有付款方式**都會觸發（匯款轉帳、線上刷卡）

**發送位置**：`server.js` (951-976行)

**發送流程**：
```javascript
// 1. 取得管理員 Email（優先使用資料庫設定）
const adminEmail = await db.getSetting('admin_email') || 
                   process.env.ADMIN_EMAIL || 
                   'cheng701107@gmail.com';

// 2. 生成管理員通知郵件
const adminMailOptions = {
    from: emailUser,
    to: adminEmail,
    subject: `【新訂房通知】${guestName} - ${bookingId}`,
    html: generateAdminEmail(bookingData)
};

// 3. 發送郵件（優先 Gmail API，失敗時切換 SMTP）
if (sendEmailViaGmailAPI) {
    try {
        await sendEmailViaGmailAPI(adminMailOptions);
    } catch (gmailError) {
        await transporter.sendMail(adminMailOptions);
    }
} else {
    await transporter.sendMail(adminMailOptions);
}
```

**郵件內容**：
- 客戶基本資料（姓名、電話、Email）
- 訂房詳細資訊（日期、房型、金額）
- 加購商品資訊
- 支付方式

**注意**：此郵件發送失敗**不會影響**訂房流程，僅記錄錯誤日誌。

---

### 3. 付款完成確認郵件（客戶）

**觸發時機**：
- 線上刷卡付款完成後
- 綠界支付回傳成功

**發送位置**：
- `server.js` (3044-3125行) - 測試環境
- `server.js` (3246-3333行) - 正式環境

**發送流程**：
```javascript
// 1. 付款完成後，生成確認郵件
const customerMailOptions = {
    from: emailUser,
    to: booking.guest_email,
    subject: '【訂房確認】您的訂房已成功',
    html: await generateCustomerEmail(bookingData)
};

// 2. 發送郵件（優先 Gmail API）
if (sendEmailViaGmailAPI) {
    try {
        await sendEmailViaGmailAPI(customerMailOptions);
        emailSent = true;
    } catch (gmailError) {
        try {
            await transporter.sendMail(customerMailOptions);
            emailSent = true;
        } catch (smtpError) {
            console.error('確認郵件發送失敗');
        }
    }
} else {
    await transporter.sendMail(customerMailOptions);
    emailSent = true;
}

// 3. 更新郵件狀態
if (emailSent) {
    await db.updateEmailStatus(bookingId, 'booking_confirmation');
}
```

**郵件內容**：與「訂房確認郵件」相同

---

### 4. 匯款期限提醒郵件（客戶）

**觸發時機**：
- 定時任務：每小時整點執行（`0 * * * *`）
- 檢查時間：根據郵件模板中的 `send_hour_payment_reminder` 設定（預設 9:00）
- 只有在設定的時間才會發送

**發送位置**：`server.js` (4173-4300行)

**查詢條件**：
- 付款方式為「匯款轉帳」
- 付款狀態為「待付款」（`pending`）
- 訂房狀態為「保留」（`reserved`）
- 訂房建立日期在保留期限內
- 尚未發送過匯款提醒郵件

**發送流程**：
```javascript
async function sendPaymentReminderEmails() {
    // 1. 取得匯款提醒模板
    const template = await db.getEmailTemplateByKey('payment_reminder');
    
    // 2. 檢查模板是否啟用
    if (!template || !template.is_enabled) {
        return; // 模板未啟用，跳過
    }
    
    // 3. 檢查當前時間是否符合發送時間
    const sendHour = parseInt(template.send_hour_payment_reminder) || 9;
    const currentHour = new Date().toLocaleString('zh-TW', { 
        timeZone: 'Asia/Taipei', 
        hour: '2-digit', 
        hour12: false 
    });
    
    if (parseInt(currentHour) !== sendHour) {
        return; // 不是發送時間，跳過
    }
    
    // 4. 查詢需要發送提醒的訂房
    const bookings = await db.getBookingsForPaymentReminder();
    
    // 5. 發送郵件給每個訂房
    for (const booking of bookings) {
        const { subject, content } = await replaceTemplateVariables(template, booking, bankInfo);
        
        const mailOptions = {
            from: emailUser,
            to: booking.guest_email,
            subject: subject,
            html: content
        };
        
        // 發送郵件（優先 Gmail API）
        if (sendEmailViaGmailAPI) {
            try {
                await sendEmailViaGmailAPI(mailOptions);
            } catch (gmailError) {
                await transporter.sendMail(mailOptions);
            }
        } else {
            await transporter.sendMail(mailOptions);
        }
        
        // 6. 更新郵件狀態
        await db.updateEmailStatus(booking.booking_id, 'payment_reminder');
    }
}
```

**郵件內容**：使用郵件模板 `payment_reminder`，支援變數替換

---

### 5. 入住提醒郵件（客戶）

**觸發時機**：
- 定時任務：每小時整點執行（`0 * * * *`）
- 檢查時間：根據郵件模板中的 `send_hour_checkin` 設定（預設 10:00）
- 只有在設定的時間才會發送

**發送位置**：`server.js` (4495-4580行)

**查詢條件**：
- 訂房狀態為「有效」（`active`）
- 入住日期為「明天」（根據模板的 `days_before_checkin` 設定）
- 尚未發送過入住提醒郵件

**發送流程**：
```javascript
async function sendCheckinReminderEmails() {
    // 1. 取得入住提醒模板
    const template = await db.getEmailTemplateByKey('checkin_reminder');
    
    // 2. 檢查模板是否啟用
    if (!template || !template.is_enabled) {
        return;
    }
    
    // 3. 檢查當前時間是否符合發送時間
    const sendHour = parseInt(template.send_hour_checkin) || 10;
    const currentHour = new Date().toLocaleString('zh-TW', { 
        timeZone: 'Asia/Taipei', 
        hour: '2-digit', 
        hour12: false 
    });
    
    if (parseInt(currentHour) !== sendHour) {
        return;
    }
    
    // 4. 查詢需要發送提醒的訂房
    const bookings = await db.getBookingsForCheckinReminder(daysBeforeCheckin);
    
    // 5. 發送郵件
    for (const booking of bookings) {
        const { subject, content } = await replaceTemplateVariables(template, booking);
        
        const mailOptions = {
            from: emailUser,
            to: booking.guest_email,
            subject: subject,
            html: content
        };
        
        // 發送郵件（優先 Gmail API）
        if (sendEmailViaGmailAPI) {
            try {
                await sendEmailViaGmailAPI(mailOptions);
            } catch (gmailError) {
                await transporter.sendMail(mailOptions);
            }
        } else {
            await transporter.sendMail(mailOptions);
        }
        
        // 6. 更新郵件狀態
        await db.updateEmailStatus(booking.booking_id, 'checkin_reminder');
    }
}
```

**郵件內容**：使用郵件模板 `checkin_reminder`，支援變數替換

---

### 6. 回訪信郵件（客戶）

**觸發時機**：
- 定時任務：每小時整點執行（`0 * * * *`）
- 檢查時間：根據郵件模板中的 `send_hour_feedback` 設定（預設 11:00）
- 只有在設定的時間才會發送

**發送位置**：`server.js` (4565-4669行)

**查詢條件**：
- 訂房狀態為「有效」（`active`）
- 退房日期為「昨天」（根據模板的 `days_after_checkout` 設定）
- 尚未發送過回訪信

**發送流程**：
```javascript
async function sendFeedbackRequestEmails() {
    // 1. 取得回訪信模板
    const template = await db.getEmailTemplateByKey('feedback_request');
    
    // 2. 檢查模板是否啟用
    if (!template || !template.is_enabled) {
        return;
    }
    
    // 3. 檢查當前時間是否符合發送時間
    const sendHour = parseInt(template.send_hour_feedback) || 11;
    const currentHour = new Date().toLocaleString('zh-TW', { 
        timeZone: 'Asia/Taipei', 
        hour: '2-digit', 
        hour12: false 
    });
    
    if (parseInt(currentHour) !== sendHour) {
        return;
    }
    
    // 4. 查詢需要發送回訪信的訂房
    const bookings = await db.getBookingsForFeedbackRequest(daysAfterCheckout);
    
    // 5. 發送郵件
    for (const booking of bookings) {
        const { subject, content } = await replaceTemplateVariables(template, booking);
        
        const mailOptions = {
            from: emailUser,
            to: booking.guest_email,
            subject: subject,
            html: content
        };
        
        // 發送郵件（優先 Gmail API）
        if (sendEmailViaGmailAPI) {
            try {
                await sendEmailViaGmailAPI(mailOptions);
            } catch (gmailError) {
                await transporter.sendMail(mailOptions);
            }
        } else {
            await transporter.sendMail(mailOptions);
        }
        
        // 6. 更新郵件狀態
        await db.updateEmailStatus(booking.booking_id, 'feedback_request');
    }
}
```

**郵件內容**：使用郵件模板 `feedback_request`，支援變數替換

---

### 7. 取消通知郵件（客戶）

**觸發時機**：
- 定時任務：每小時整點執行（`0 * * * *`）
- 自動取消過期保留訂房時發送

**發送位置**：`server.js` (4393-4492行)

**查詢條件**：
- 付款方式為「匯款轉帳」
- 付款狀態為「待付款」（`pending`）
- 訂房狀態為「保留」（`reserved`）
- 當前時間超過保留期限（訂房建立日期 + 保留天數）

**發送流程**：
```javascript
async function cancelExpiredReservations() {
    // 1. 取得匯款提醒模板以取得保留天數
    const paymentTemplate = await db.getEmailTemplateByKey('payment_reminder');
    const daysReserved = parseInt(paymentTemplate?.days_reserved) || 3;
    
    // 2. 查詢過期保留訂房
    const bookings = await db.getBookingsForPaymentReminder();
    
    // 3. 檢查並取消過期訂房
    for (const booking of bookings) {
        const bookingDate = new Date(booking.created_at);
        const deadline = new Date(bookingDate);
        deadline.setDate(deadline.getDate() + daysReserved);
        
        if (now > deadline) {
            // 取消訂房
            await db.cancelBooking(booking.booking_id);
            
            // 4. 發送取消通知郵件
            const cancellationEmail = await generateCancellationEmail(booking);
            const mailOptions = {
                from: emailUser,
                to: booking.guest_email,
                subject: '【訂房取消通知】您的訂房已自動取消',
                html: cancellationEmail
            };
            
            // 發送郵件（優先 Gmail API）
            if (sendEmailViaGmailAPI) {
                try {
                    await sendEmailViaGmailAPI(mailOptions);
                } catch (gmailError) {
                    await transporter.sendMail(mailOptions);
                }
            } else {
                await transporter.sendMail(mailOptions);
            }
        }
    }
}
```

**郵件內容**：使用 `generateCancellationEmail()` 函數生成，包含取消的訂房資訊

**注意**：此郵件發送後**不會更新** `email_sent` 狀態

---

### 8. 驗證碼郵件（客戶）

**觸發時機**：
- 客戶申請查看個資時
- 客戶申請刪除個資時

**發送位置**：`server.js` (2020-2070行) + `data-protection.js` (68-248行)

**發送流程**：
```javascript
// 1. 生成驗證碼
const code = dataProtection.generateVerificationCode();
dataProtection.saveVerificationCode(email, code, purpose);

// 2. 發送驗證碼郵件
await dataProtection.sendVerificationEmail(email, code, purpose);
```

**郵件內容**：簡單的驗證碼通知郵件

**注意**：此郵件使用獨立的郵件服務設定（`data-protection.js`），不影響主系統的郵件狀態

---

### 9. 測試郵件

**觸發時機**：
- 管理員在後台測試郵件模板時
- 手動觸發

**發送位置**：`server.js` (3646-3764行)

**發送流程**：
```javascript
// 1. 取得模板內容
const template = await db.getEmailTemplateByKey(key);

// 2. 使用測試資料替換變數
const testData = {
    guestName: '測試用戶',
    bookingId: 'TEST' + Date.now().toString().slice(-6),
    // ... 其他測試資料
};

// 3. 替換模板變數
let testContent = content;
Object.keys(testData).forEach(key => {
    testContent = testContent.replace(new RegExp(`\\{\\{${key}\\}\\}`, 'g'), testData[key]);
});

// 4. 發送測試郵件
const mailOptions = {
    from: emailUser,
    to: email,  // 指定的測試 Email
    subject: `[測試] ${testSubject}`,
    html: testContent
};

await sendEmailViaGmailAPI(mailOptions);
```

**郵件內容**：使用郵件模板內容，變數替換為測試資料

---

## 🔧 郵件發送技術細節

### 發送方式優先順序

1. **Gmail API**（優先）
   - 使用 OAuth2 認證
   - 更穩定，適合 Railway 環境
   - 失敗時自動切換到 SMTP

2. **SMTP**（備用）
   - 使用 OAuth2 或應用程式密碼
   - Gmail API 失敗時使用

### 發件人設定

- **優先順序**：
  1. 資料庫設定：`email_user`
  2. 環境變數：`EMAIL_USER`
  3. 預設值：`cheng701107@gmail.com`

- **重要**：使用 Gmail API 時，`from` 欄位必須與 OAuth2 認證帳號一致，否則會自動使用 OAuth2 認證帳號

### 錯誤處理

- 所有郵件發送都有 try-catch 錯誤處理
- Gmail API 失敗時自動切換到 SMTP
- 錯誤會記錄到日誌，但不會中斷主要流程（管理員通知郵件除外）

---

## 📊 郵件狀態管理

### 郵件狀態格式

- **舊格式**：整數 `0`（未發送）或 `1`（已發送）
- **新格式**：字串，多個郵件類型用逗號分隔，例如：`booking_confirmation,checkin_reminder`

### 郵件狀態更新

| 郵件類型 | 狀態鍵值 | 是否更新 |
|---------|---------|---------|
| 訂房確認 | `booking_confirmation` | ✅ |
| 匯款提醒 | `payment_reminder` | ✅ |
| 入住提醒 | `checkin_reminder` | ✅ |
| 回訪信 | `feedback_request` | ✅ |
| 新訂房通知 | - | ❌ |
| 取消通知 | - | ❌ |
| 驗證碼 | - | ❌ |
| 測試郵件 | - | ❌ |

---

## ⚙️ 定時任務設定

所有定時任務都使用台灣時區（`Asia/Taipei`），每小時整點執行：

```javascript
// 每小時整點執行
cron.schedule('0 * * * *', functionName, {
    timezone: 'Asia/Taipei'
});
```

**定時任務列表**：
1. `sendPaymentReminderEmails()` - 匯款提醒
2. `sendCheckinReminderEmails()` - 入住提醒
3. `sendFeedbackRequestEmails()` - 回訪信
4. `cancelExpiredReservations()` - 自動取消過期訂房

---

## 🔍 除錯建議

### 檢查郵件發送問題

1. **檢查日誌**：
   - 查看 Railway 日誌中的郵件發送記錄
   - 確認是否有錯誤訊息

2. **檢查設定**：
   - 確認「郵件設定」中的 Gmail 參數是否正確
   - 確認 `email_user` 與 OAuth2 認證帳號一致

3. **檢查郵件狀態**：
   - 在後台查看訂房的郵件狀態
   - 確認郵件是否已標記為已發送

4. **測試郵件功能**：
   - 使用後台的「測試郵件」功能
   - 確認郵件服務是否正常運作

---

## 📝 注意事項

1. **Gmail 發信限制**：
   - 免費帳號：每天最多 500 封
   - Google Workspace：每天最多 2,000 封
   - 所有系統共用同一個配額

2. **郵件發送失敗處理**：
   - 客戶郵件發送失敗會記錄錯誤，但不影響訂房流程
   - 管理員通知郵件失敗不影響訂房流程

3. **郵件狀態更新**：
   - 只有成功發送才會更新郵件狀態
   - 失敗時不會更新狀態，下次定時任務會重試

4. **定時任務執行時間**：
   - 每小時整點執行
   - 只有在模板設定的時間才會發送
   - 使用台灣時區（Asia/Taipei）

